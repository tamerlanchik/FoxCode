Классической архитектурой мобильных приложений
является MVC: Model-View-Controller
Model - данные, View - интерфейс пользователя, Controller - связующее, выполняющее основные вычисления (Обычно Activity с компанией)

Основой Android-приложения является Activity (в нашем случае оно зовется MainActivity)
Оно является владельцем текущего потока, в котором выполняется его интерфейс
и все связанные с ним контекстом (Context) задачи. Как правило, в приложениям
есть несколько Activity, каждое выполняет какую-то отдельну задачу и имеет
персональный дизайн. У нас пока одно.

View - графическая часть приложения. Она отображает необхожимую информацию
и интерактивно взаимодействует с пользователем. Выполняется в одном потоке с Activity.
Представлена файлами макета ***_layout.xml (основной - activity_layout.xml)

GLMapView (наследник GLSurfaceView) - элемент View, на котором будет рисоваться карта,
и который впоследствии будет позволять выбирать на нём кабинеты. 
Перегружен для инициализации объекта GLSurfaceView.Renderer и передачи управляющих сигналов
и событий в MapDrawer через кросс-язычный посредний MapDrawerJNI.
Замечание: я настроил Renderer так, что он запускает процесс рисования не постоянно, а по требованию
(при изменении картинки, повороте устройства и т.д.), т.е. довольно редко.

MapDrawer - будет заниматься отрисовкой и сопутствующими ей задачами.

ShaderMaster - занимается загрузкой [из локального хранилища assets] и компиляцией шейдеров - примитивных объектов,
которые являются базой графической технологии OpenGL

MapGuide - класс, который заведует маршрутами (там будет алгоритм поиска пути).
Живёт в отдельном потоке.

MapItem - примитивный обьект, рисуемый на карте (комната, коридор, лестница и тд.)
Знает свое местоположение, размеры и умеет рисовать себя на предоставленной канве.
Абстрактный класс, ибо каждый тип обьектов рисуется по особому (лестница, как минимум).

ItemsStorageSinglet - класс-хранилище примитивных карточных обьектов.
В Android каждый обьект имеет время жизни, совпадающее с таковым у своего владельца.
По умолчанию владельцем всего является текущее Activity. Но оно в течение жизни приложения
может уничтожаться и создаваться заново. Чтобы данные не потерять и не загружать заново,
мы связываем хранилище с самим приложением. Сколько живет приложение, столько живут данные.
Для отрисовки не столь важно, в какой структуре данных хранятся примитивы. Если этот класс будет 
единственным хранилищем, тогда это будет часть графа.

??? Кто будет обновлять хранилище ItemStorageSinglet? Он сам, блокируя обращения к себе на время обновления,
или другой класс на стороне Java через очередной кросс-язычный интерфейс?

DatabaseMaster - класс, который предоставляет высокоуровневый интерфейс для работы с базой.
Также занимается её обновлением (или в отдельный класс засунуть??)

NetworkMaster - класс, работающий с сетью. Выполняет задачи по требованию.
У нас вначале будет грузить данные с сервера и проверять свежесть текущей локальной базы. Разумеется, запускается по заявке в отдельном потоке.

ActualDatabaseService - фоновый сервис, который отвечает за актуальность базы и других данных.
Сам будет принимать новые данные, или вызовет Networkmaster - хороший вопрос на конец мая.

